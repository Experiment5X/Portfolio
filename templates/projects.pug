extends base.pug

block content
  h1 Personal Projects

  section#garbage-full-detector
    .project-title-container
      h4.project-title Garbage Full Detector
      a(href='https://github.com/Experiment5X/GarbageFullDetector').project-title-link
        span.github-icon.mx-1 
        | View on GitHub
    
    p I built a device that will look at a garbage can and notify people when it becomes full. If the garbage stays full and is not emptied within 10 minutes then a text will be sent out to everyone in the house with a link to a GIF showing the person fill it up and not empty it.
    
    p I used a raspberry pi with a camera attached to it to capture the images of the garbage and perform all of the processing. I trained a machine learning model to classify pictures of my garbage can as either full or empty, to know when to trigger the notifications. To send out the texts to everyone I used the AWS service SNS which was really easy to set up. The device is configurable by visiting a website that runs on the pi. 


    div
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Python
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Keras
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Machine Learning
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Javascript
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Node
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Bootstrap

  section#seam-carving
    .project-title-container
      h4.project-title Seam Carving
      a(href='https://github.com/Experiment5X/SeamCarving').project-title-link
        span.github-icon.mx-1 
        | View on GitHub
    p I came across the seam carving algorithm and thought it was really cool so I implemented it. The algorithm will resize images and preserve the content inside the image without stretching or scrunching parts of the image so it looks natural. The same principle used in this algorithm can be used to add pixels to images to make them larger and to draw over existing pixels to remove objects from the images.
    div
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Python

  section#deep-feature-visualization
    .project-title-container
      h4.project-title Deep Feature Visualization
      a(href='https://github.com/Experiment5X/DeepFeatureVisualizationWebApp').project-title-link
        span.github-icon.mx-1 
        | View on GitHub
    p I was inspired by Chris Olah's work on visualizing convolutional neural networks so I built a tool of my own to visualize the feature map of any image at any layer in the popular CNN VGG16. It works by passing the image through the network up to a certain layer to compute a feature map. To visualize this feature map, gradient descent is performed to get another image with a feature map as close to the original image's feature map as possible. The loss for this optimization is simply the sum of the element-wise difference between the two feature maps.
    p This works quite well and some interesting images were produced using this technique. The web application I built makes it super simple to select a picture, and a layer in VGG16 that you want to visualize it at. The program also allows you edit some parameters that change the way the feature map visualization image is produced. Checkout my GitHub repo linked above to see some of these images.
    div
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Python
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Django
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Keras 
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Machine Learning 
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Javascript
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Bootstrap

  section#swisp
    .project-title-container
      h4.project-title Swisp
      a(href='https://github.com/Experiment5X/Swisp').project-title-link
        span.github-icon.mx-1 
        | View on GitHub
    p This is a basic interpreter for a subset of lisp. It has support for the basic data types (int, float, string, list) and also has support for defining functions. The goal of writing this project was to learn more about Lisp and interpreters.
    div
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Swift
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Lisp

  section#velocity
    .project-title-container
      h4.project-title Velocity
      a(href='https://github.com/hetelek/Velocity').project-title-link
        span.github-icon.mx-1 
        | View on GitHub
    p This application implements most of the proprietary file systems that Microsoft uses for the Xbox 360. I wrote this application alongside my friend, with both of us writing about 50% of the code. We built a GUI tool that allows users to easily view the contents of their 360 hard drives and user content packages. We also created a profile editor providing features for users to modify locked aspects of their profile, unlock achievements, and unlock avatar awards all at the click of a button. Users could create profiles, add games to their account, create picture packs, view Xbox executables, and games installed to their disk. When we released the application in 2012 we made a video showing it off on #[a(href='https://www.youtube.com/watch?v=w-i8qUhX2jE') YouTube]. This was before we had support for hard drives, installed games, and executable files.
    p The file system used on the hard drives is a modified version of a FAT32, called FATX. There is a secure package format called STFS for storing player content that uses a merkle tree similar to ZFS to avoid corruption. These packages are also signed to prevent people from modifying them. However, all non-DLC is self-signed so Velocity has a feature to fix all of the hashes in the merkle tree and sign the file so that people can modify their profiles or savegames and their Xbox 360's will accept them.
    p In order for us to understand how these file systems actually worked we reverse engineered the Xbox 360's kernel and system library code. There was some documentation online about STFS but it was incomplete. There were key details that were missing that we uncovered by understanding the PowerPC assembly and looking at the files in a hex editor for a long time. 

    div
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 C++
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Qt 
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 PowerPC
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Reverse Engineering
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 File Systems

  section#xbdm
    .project-title-container
      h4.project-title XBDM
      a(href='https://github.com/Experiment5X/XBDM').project-title-link
        span.github-icon.mx-1 
        | View on GitHub
    p XBDM is the protocol used to communicate with Xbox 360 development kits. You can do things like transfer files, set breakpoints, read memory, take screenshots, view processes, etc. The protocol is used by Microsoft's tools to help developers but those only run on Windows. I wanted to be able to control mine from my Mac so I reverse engineered Microsoft's library and used Wireshark to look at the network traffic. Once I understood the protocol I wrote this library in C++ so it would work cross platform. Then I wrote a cross-platform GUI manager using the Qt framework called #[a(href='https://github.com/Experiment5X/360DevManager') 360DevManager].
    div
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 C++
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Qt 
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 x86
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Reverse Engineering
      span.badge.badge-pill.badge-secondary.mx-1.mb-1 Wireshark